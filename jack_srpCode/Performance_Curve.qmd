---
title: "Performance_Curve"
format: html
editor: visual
---

```{r}
# Performance Curve
# ---- Build a library of covariance matrices across dimensions ----
set.seed(10086)               # for reproducibility
dimensions <- 4:10           # which dimensions to sample
n_per_dim <- 1              # how many Σ to draw per dimension (tweak as you like)

Sigma_results <- vector("list", length(dimensions) * n_per_dim)
idx <- 1

for (d in dimensions) {
  for (rep in seq_len(n_per_dim)) {
    Sigma <- generate_cov_matrix(d)

    # Eigen decomposition (Sigma is symmetric p.d.)
    eig <- eigen(Sigma, symmetric = TRUE)
    vals <- eig$values
    vecs <- eig$vectors

    leading_vector <- vecs[, which.max(vals)]
    lagging_vector <- vecs[, which.min(vals)]

    Sigma_results[[idx]] <- tibble::tibble(
      Dimension            = d,
      Replicate            = rep,
      Covariance_Matrix    = list(Sigma),
      Eigenvalues          = list(vals),
      Leading_Eigenvector  = list(leading_vector),
      Lagging_Eigenvector  = list(lagging_vector)
    )
    idx <- idx + 1
  }
}

# Combine into one tibble and add an ID
Sigma_plot_data <- dplyr::bind_rows(Sigma_results) |>
  dplyr::mutate(Sigma_ID = dplyr::row_number())

# Preview
Sigma_plot_data

# Print each covariance matrix cleanly
for (i in seq_len(nrow(Sigma_plot_data))) {
  cat("\n--- Covariance Matrix (Dim =", Sigma_plot_data$Dimension[i],
      ", Replicate =", Sigma_plot_data$Replicate[i], ") ---\n")
  print(round(Sigma_plot_data$Covariance_Matrix[[i]], 3))
}

```

```{r}
# ---- Build μ along leading/lagging eigen-directions for each Σ ----
set.seed(10086)

# Target squared L2 norms for ||μ||^2
target_l2_norms <- seq(0.01, 10, by = 0.01)

Mu_scaled_results <- vector("list", length = nrow(Sigma_plot_data) * length(target_l2_norms) * 2L)
k <- 1L

# ---- Helper: Expected risk under your SURE formula ----
bock_expected_risk <- function(mu, cov_matrix) {
  ev <- eigen(cov_matrix, symmetric = TRUE, only.values = TRUE)$values
  Tr_sigma   <- sum(ev)
  lambda_max <- max(ev)
  p <- Tr_sigma / lambda_max
  
  E1 <- pracma::quadinf(joint_mgf,      0, Inf, mu = mu, cov_matrix = cov_matrix)$Q   # E[1/(Y'Y)]
  E2 <- pracma::quadinf(integrand_mu_2, 0, Inf, mu = mu, cov_matrix = cov_matrix)$Q   # E[(Y Σ^-1 Y)/(Y'Y)^2]
  
  Tr_sigma + (p^2 - 4) * E2 - 2 * (p - 2) * Tr_sigma * E1
}

# Example:
# cat(bock_expected_risk(mu, cov_matrix), "is the expected risk\n")
for (i in seq_len(nrow(Sigma_plot_data))) {
  d        <- Sigma_plot_data$Dimension[i]
  Sigma    <- Sigma_plot_data$Covariance_Matrix[[i]]
  lead_vec <- Sigma_plot_data$Leading_Eigenvector[[i]]
  lag_vec  <- Sigma_plot_data$Lagging_Eigenvector[[i]]

  # Normalize directions
  lead_vec <- lead_vec / sqrt(sum(lead_vec^2))
  lag_vec  <- lag_vec  / sqrt(sum(lag_vec^2))

  for (l2 in target_l2_norms) {
    sc <- sqrt(l2)

    mu_lead <- as.vector(lead_vec * sc)
    mu_lag  <- as.vector(lag_vec  * sc)

    # Expected risk via Bock SURE if available; else NA
    ER_lead <- bock_expected_risk(mu = mu_lead, cov_matrix = Sigma)
    ER_lag  <- bock_expected_risk(mu = mu_lag, cov_matrix = Sigma)

    Mu_scaled_results[[k]] <- tibble::tibble(
      Sigma_ID      = Sigma_plot_data$Sigma_ID[i],
      Dimension     = d,
      Squared_L2    = l2,
      Direction     = "Leading",
      Mu            = list(mu_lead),
      Covariance    = list(Sigma),
      Trace_Sigma   = sum(diag(Sigma)),
      Lambda_Max    = max(eigen(Sigma, symmetric = TRUE, only.values = TRUE)$values),
      Expected_Risk = ER_lead
    ); k <- k + 1L

    Mu_scaled_results[[k]] <- tibble::tibble(
      Sigma_ID      = Sigma_plot_data$Sigma_ID[i],
      Dimension     = d,
      Squared_L2    = l2,
      Direction     = "Lagging",
      Mu            = list(mu_lag),
      Covariance    = list(Sigma),
      Trace_Sigma   = sum(diag(Sigma)),
      Lambda_Max    = max(eigen(Sigma, symmetric = TRUE, only.values = TRUE)$values),
      Expected_Risk = ER_lag
    ); k <- k + 1L
  }
}

Mu_scaled_tibble <- dplyr::bind_rows(Mu_scaled_results)

# Preview
Mu_scaled_tibble
```

```{r}
# ---- Performance curves: Scaled Expected Risk vs ||Σ^{-1} μ||^2 ----
# Compute ||Σ^{-1} μ||^2 and scaled risk
Mu_scaled_tibble <- Mu_scaled_tibble |>
  mutate(
    Scaled_Risk = Expected_Risk / Dimension,
    Mahalanobis = map2_dbl(Mu, Covariance, ~ as.numeric(t(.x) %*% solve(.y, .x)))
  )

Mu_scaled_tibble
```

```{r}

# --- Build baseline table: trace(Sigma)/d for each dimension ---
baseline_tbl <- Mu_scaled_tibble |>
  distinct(Dimension, Trace_Sigma) |>
  group_by(Dimension) |>
  summarise(
    Baseline = median(Trace_Sigma / Dimension),
    .groups = "drop"
  )

Mu_centered <- Mu_scaled_tibble |>
  left_join(baseline_tbl, by = "Dimension") |>
  mutate(
    y_centered = Scaled_Risk - Baseline
  )
max_range <- max(abs(Mu_centered$y_centered))

my_plot_scaled <- Mu_centered |>
  ggplot(
    aes(
      x     = Squared_L2,
      y     = y_centered,
      color = Direction
    )
  ) +
  geom_line(aes(group = Direction), linewidth = 1.1) +
  
  # horizontal zero line = baseline
  geom_hline(yintercept = 0, linetype = "dashed", color = "black", linewidth = 0.9) +
  
  facet_wrap(~ Dimension, scales = "free_y") +
  
  labs(
    title = "Bock SURE Performance: Scaled Risk (Centered) vs ||μ||²",
    x     = expression("||" * mu * "||"^2),
    y     = "Centered Expected Risk / Dimension",
    color = "Direction"
  ) +
  
  # NOW you can use a single ylim, because all facets have baseline == 0
  ylim(-max_range, max_range) +
  
  theme_minimal(base_size = 13)


print(my_plot_scaled)

```

build curve on sigma inverse mu on the x axis

y aaxis on scaled risk

and one horizontal line for the trace

another two lines for leading and algging eigen value direction
