---
title: "Performance_Curve"
format: html
editor: visual
---

```{r}
# Performance Curve
# ---- Build a library of covariance matrices across dimensions ----
set.seed(123)               # for reproducibility
dimensions <- 3:8           # which dimensions to sample
n_per_dim <- 1              # how many Σ to draw per dimension (tweak as you like)

Sigma_results <- vector("list", length(dimensions) * n_per_dim)
idx <- 1

for (d in dimensions) {
  for (rep in seq_len(n_per_dim)) {
    Sigma <- generate_cov_matrix(d)

    # Eigen decomposition (Sigma is symmetric p.d.)
    eig <- eigen(Sigma, symmetric = TRUE)
    vals <- eig$values
    vecs <- eig$vectors

    leading_vector <- vecs[, which.max(vals)]
    lagging_vector <- vecs[, which.min(vals)]

    Sigma_results[[idx]] <- tibble::tibble(
      Dimension            = d,
      Replicate            = rep,
      Covariance_Matrix    = list(Sigma),
      Eigenvalues          = list(vals),
      Leading_Eigenvector  = list(leading_vector),
      Lagging_Eigenvector  = list(lagging_vector)
    )
    idx <- idx + 1
  }
}

# Combine into one tibble and add an ID
Sigma_plot_data <- dplyr::bind_rows(Sigma_results) |>
  dplyr::mutate(Sigma_ID = dplyr::row_number())

# Preview
Sigma_plot_data

# Print each covariance matrix cleanly
for (i in seq_len(nrow(Sigma_plot_data))) {
  cat("\n--- Covariance Matrix (Dim =", Sigma_plot_data$Dimension[i],
      ", Replicate =", Sigma_plot_data$Replicate[i], ") ---\n")
  print(round(Sigma_plot_data$Covariance_Matrix[[i]], 3))
}

```

```{r}
# ---- Build μ along leading/lagging eigen-directions for each Σ ----
set.seed(1)

# Target squared L2 norms for ||μ||^2
target_l2_norms <- seq(0.01, 5, by = 0.02)

Mu_scaled_results <- vector("list", length = nrow(Sigma_plot_data) * length(target_l2_norms) * 2L)
k <- 1L

# ---- Helper: Expected risk under your SURE formula ----
bock_expected_risk <- function(mu, cov_matrix) {
  ev <- eigen(cov_matrix, symmetric = TRUE, only.values = TRUE)$values
  Tr_sigma   <- sum(ev)
  lambda_max <- max(ev)
  p <- Tr_sigma / lambda_max
  
  E1 <- pracma::quadinf(joint_mgf,      0, Inf, mu = mu, cov_matrix = cov_matrix)$Q   # E[1/(Y'Y)]
  E2 <- pracma::quadinf(integrand_mu_2, 0, Inf, mu = mu, cov_matrix = cov_matrix)$Q   # E[(Y Σ^-1 Y)/(Y'Y)^2]
  
  Tr_sigma + (p^2 - 4) * E1 - 2 * (p - 2) * Tr_sigma * E2
}

# Example:
# cat(bock_expected_risk(mu, cov_matrix), "is the expected risk\n")
for (i in seq_len(nrow(Sigma_plot_data))) {
  d        <- Sigma_plot_data$Dimension[i]
  Sigma    <- Sigma_plot_data$Covariance_Matrix[[i]]
  lead_vec <- Sigma_plot_data$Leading_Eigenvector[[i]]
  lag_vec  <- Sigma_plot_data$Lagging_Eigenvector[[i]]

  # Normalize directions
  lead_vec <- lead_vec / sqrt(sum(lead_vec^2))
  lag_vec  <- lag_vec  / sqrt(sum(lag_vec^2))

  for (l2 in target_l2_norms) {
    sc <- sqrt(l2)

    mu_lead <- as.vector(lead_vec * sc)
    mu_lag  <- as.vector(lag_vec  * sc)

    # Expected risk via Bock SURE if available; else NA
    ER_lead <- bock_expected_risk(mu = mu_lead, cov_matrix = Sigma)
    ER_lag  <- bock_expected_risk(mu = mu_lag, cov_matrix = Sigma)

    Mu_scaled_results[[k]] <- tibble::tibble(
      Sigma_ID      = Sigma_plot_data$Sigma_ID[i],
      Dimension     = d,
      Squared_L2    = l2,
      Direction     = "Leading",
      Mu            = list(mu_lead),
      Covariance    = list(Sigma),
      Trace_Sigma   = sum(diag(Sigma)),
      Lambda_Max    = max(eigen(Sigma, symmetric = TRUE, only.values = TRUE)$values),
      Expected_Risk = ER_lead
    ); k <- k + 1L

    Mu_scaled_results[[k]] <- tibble::tibble(
      Sigma_ID      = Sigma_plot_data$Sigma_ID[i],
      Dimension     = d,
      Squared_L2    = l2,
      Direction     = "Lagging",
      Mu            = list(mu_lag),
      Covariance    = list(Sigma),
      Trace_Sigma   = sum(diag(Sigma)),
      Lambda_Max    = max(eigen(Sigma, symmetric = TRUE, only.values = TRUE)$values),
      Expected_Risk = ER_lag
    ); k <- k + 1L
  }
}

Mu_scaled_tibble <- dplyr::bind_rows(Mu_scaled_results)

# Preview
Mu_scaled_tibble

```

```{r}
# ---- Performance curves: Scaled Expected Risk vs ||μ||^2 ----
# If Expected_Risk has NAs, fill them using your helper bock_expected_risk(mu, Sigma)
if (!"Expected_Risk" %in% names(Mu_scaled_tibble) || any(is.na(Mu_scaled_tibble$Expected_Risk))) {
  stopifnot(exists("bock_expected_risk"))
  Mu_scaled_tibble <- Mu_scaled_tibble |>
    dplyr::mutate(
      Expected_Risk = dplyr::if_else(
        is.na(Expected_Risk),
        purrr::map2_dbl(Mu, Covariance, ~ bock_expected_risk(.x, .y)),
        Expected_Risk
      )
    )
}

my_plot <- Mu_scaled_tibble |>
  dplyr::mutate(Scaled_Risk = Expected_Risk / Dimension) |>
  ggplot2::ggplot(
    ggplot2::aes(
      x = Squared_L2,
      y = Scaled_Risk,
      group = interaction(Sigma_ID, Direction),
      color = Direction
    )
  ) +
  ggplot2::geom_line(alpha = 0.45, linewidth = 0.6) +                 # one curve per Σ & direction
  ggplot2::stat_summary(                                              # median overlay by direction
    aes(group = Direction, color = Direction),
    fun = median, geom = "line", linewidth = 1.1
  ) +
  ggplot2::facet_wrap(~ Dimension, scales = "free_y") +
  ggplot2::labs(
    title = "Bock SURE Performance: Scaled Expected Risk vs. ||μ||²",
    x = expression("||" * mu * "||"^2),
    y = "Expected Risk / Dimension",
    color = "Direction"
  ) +
  ggplot2::theme_minimal(base_size = 13)

print(my_plot)
ggplot2::ggsave("my_plot.png", plot = my_plot, width = 8, height = 5, dpi = 300)

```
